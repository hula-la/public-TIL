# 🤔 ❓MSA에서의 세션 인증 방식 #6

###### 연관: #4

### 개요

앞선 개요에서 말했던 이유들 때문에 세션 인증 방식을 채택하려고 한다. MSA 에서 세선 인증 방식을 적용하기 위해서 각 마이크로 서비스에서 분산 캐시로 접근하는 방법을 생각했었다. 하지만 보통은 API 게이트웨이에서 인증 로직을 수행하는게 좋지 않나라고 생각을 해서 한번 더 생각해보려고 한다. API 게이트웨이에서 접근하면 병목현상이 발생하지 않을까 싶어서 기존에 role을 추가한 jwt 방식은 채택해서 1차적으로 거르고, 2차적으로 각 마이크로 서비스에서 ip를 확인할까 싶긴했는데, 음 다시 계속 생각해봐야겠다.



### 흠,,

찾아봐도 MSA에 세션 방식 인증 방식을 적용한 레퍼런스가 잘 안나온다. 그만큼 좋은 방법이 아닌건가,,? 다음에 다시 찾아봐야겠다. 현재까지는 Hashing을 이용해서 캐시를 분산하고 모든 마이크로 서비스에서 공유하는 것이 좋을 것 같다. 다음에 더 생각해보자.



### 결론

다음에 더 찾아봐야겠다.



# 📖 인터페이스 vs 추상클래스 #7

### 개요

인터페이스와 추상클래스의 차이에 대한 질문은 정말 많이 접했고, 항상 궁금해왔다. 이전까지 내가 알고있었던 건 둘다 인스턴스화할 수 없고 구현체로 상속해서 사용해야한다는 공통점을 가지는 것과, 차이점으로는 추상클래스는 다중상속을 하지 못하는 것이었다. 일반적으로 추상클래스는 일부 메서드를 미리 정의해둠으로써 재정의없이 사용할 수 있다라고 하지만, 인터페이스의 디폴트 기능이 생긴 이후로 인터페이스에서도 메서드를 정의할 수 있게 되었다. 그럼 추상클래스를 사용하는 이유가 뭘까? 이거에 대해 궁금증이 생겨서 더 자세히 공부해보게 되었다.



### 인터페이스에서의 변수와 메서드

- 변수는 기본적으로 static final만 가능하다.
- 기본 메서드는 default메서드로 정의할 수 있다.
- static 메서드를 정의할 수 있으며, 인터페이스로 접근할 수 있다.

```java
public interface inter {

    static final int a = 1;
  
    default void method(int i){
        System.out.println("method");
    }

    static void staticMethod() {
        System.out.println("This is a static method in MyInterface");
    }

}

```



### 추상 클래스에서의 변수

- 클래스이기 때문에 hashCode와 equals를 오버라이딩할 수 있다.
- static final 변수가 아닌 기본 변수를 정의할 수 있다.

```java
public abstract class ab {

    public int a = 1;
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ab ab = (ab) o;
        return a == ab.a;
    }

    @Override
    public int hashCode() {
        return Objects.hash(a);
    }

}
```



### **추상클래스를 사용하는 경우**

- 상속 받을 클래스들이 공통으로 가지는 메소드와 필드가 많아 **중복 멤버 통합**을 할때
- 멤버에 public 이외의 접근자(protected, private) 선언이 필요한 경우
- non-static, non-final 필드 선언이 필요한 경우 (각 인스턴스에서 상태 변경을 위한 메소드가 필요한 경우)
- 요구사항과 함께 구현 세부 정보의 일부 기능만 지정했을 때
- 하위 클래스가 오버라이드하여 재정의하는 기능들을 공유하기 위한 상속 개념을 사용할 때
- **추상 클래스**는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로, 상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 부모 클래스가 가진 기능들을 구현해야할 경우 사용한다.



### **인터페이스를 사용하는 경우**

- 어플리케이션의 기능을 정의해야 하지만 그 구현 방식이나 대상에 대해 추상화 할 때
- **서로 관련성이 없는 클래스들을 묶어 주고** 싶을때 (형제 관계)
- **다중 상속(구현)**을 통한 추상화 설계를 해야할때
- 특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우
- 클래스와 별도로 **구현 객체가 같은 동작을 한다는 것을 보장**하기 위해 사용



### 결론

참고한 블로그에 이 두가지의 차이와 각각의 필요성에 대해서 자세하게 설명되어 있어서 너무 도움이 되었다. 결론적으로 내가 딱 느낀 건, 추상클래스는 is-a 일 때 사용하고, 인터페이스는 have 관계 일 때 사용하면 좋을 것 같았다. 또한, 인터페이스에는 변수를 정의할 수는 있지만 final 필드여야하기 때문에, 디폴트 함수를 사용한다고 한들 상태변수를 이용한 메서드는 정의할 수가 없다. 참고한 블로그에서는 인터페이스-추상클래스-구현클래스의 패턴을 추천했는데, 인터페이스를 굳이 정의해야하는가에 대해서는 의문이 든다. 추상클래스에서 정의하지 않는 메서드들은 abstract 메서드로 생성하면 인터페이스를 만들었을 경우랑 똑같은 것이 아닌가,,? 곰곰히 생각해봐야겠다



### 참고

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0