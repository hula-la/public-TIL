## 스프링 자체 메모리와 레디스의 차이점

1. 성능: 스프링 자체 메모리는 서버의 메모리를 사용하기 때문에 빠르게 데이터에 접근할 수 있지만, 서버가 재시작되면 저장된 데이터가 모두 사라지는 단점이 있습니다. 반면에 레디스는 메모리 기반 데이터베이스이기 때문에 스프링보다 더 빠른 속도로 데이터에 접근할 수 있으며, 영구적으로 데이터를 저장할 수 있습니다.
2. 용도: 스프링 자체 메모리는 주로 작은 데이터나, 임시적으로 사용되는 데이터를 저장할 때 사용합니다. 게임에서는 일부 작은 데이터들에 대해서 스프링 자체 메모리를 사용할 수 있지만, 게임에서 사용되는 대부분의 데이터는 영구적으로 보존되어야 하므로 레디스를 사용하는 것이 더 적절합니다.
3. 확장성: 스프링 자체 메모리는 서버의 메모리 크기에 제한을 받기 때문에 서버를 확장할 경우에는 추가적인 서버를 구매하여 메모리 용량을 늘려야 합니다. 반면에 레디스는 클러스터링을 통해 여러 대의 서버를 연결하여 용량을 확장할 수 있습니다.

따라서, 게임 정보를 저장할 때는 대부분 레디스를 사용하는 것이 더 적합합니다. 하지만, 게임에서 사용되는 작은 데이터나, 특정한 상황에서 임시적으로 사용되는 데이터는 스프링 자체 메모리를 사용하는 것도 고려할 수 있습니다.

## 둘 다 메모리인데 왜 레디스가 더 빠를까?

1. 디스크 접근 없이 메모리에서 데이터를 처리한다 레디스는 디스크 접근 없이 메모리에서 데이터를 처리하기 때문에 입출력 속도가 더욱 빠릅니다. 반면에 스프링 자체 메모리는 서버의 메모리에 저장되어 있기 때문에 CPU와 메모리 간의 입출력 속도 차이가 존재합니다.
2. 쓰기 작업의 복잡도가 낮다 레디스는 쓰기 작업의 복잡도가 낮아서 데이터를 더 빠르게 쓰고 읽을 수 있습니다. 스프링 자체 메모리는 자바 객체를 직렬화하여 저장하기 때문에 쓰기 작업의 복잡도가 높아질 수 있습니다.
3. 네트워크 소켓 통신에서의 성능 레디스는 클라이언트-서버 구조로 구성되어 있기 때문에 네트워크 소켓 통신에서도 높은 성능을 발휘합니다. 스프링 자체 메모리는 서버 내에서만 데이터를 처리하기 때문에 네트워크 통신이 필요하지 않습니다.



---

## 필터에서 예외 핸들링

##### 개츠비

- 인증에서의 예외 처리를 담당하는 AuthenticationEntryPoint에서 예외 핸들링
- 닉네임 입력안하는 경우, 토큰 만료, 토큰 유효하지 않은 경우를 나누기 위해 request에 exception 종류를 보내고 상태코드와 메세지를 보냄
- sendError로 보내면 json 형태의 데이터를 반환하지 못함

##### 배달

- objectMapper와 getWriter을 이용해서 json을 string으로 변환한 후 전달
