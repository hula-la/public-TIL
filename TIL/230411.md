## Entity를 Controller로 노출해도 괜찮을까?

 보안성때문에 Controller까지 올리면 안된다는 말도 있고, 개발의 편리성때문에 굳이 밖으로만 안보내면 된다라는 말이 있다.

처음에는 외부로만 노출하지만 않으면 괜찮지 않나라고 생각해서 2번에 의견에 찬성을 했다.

하지만, 최근에 생각이 바꼈고, 이에 대한 이유는 다음과 같다.

1. **entity<->DTO** 변환도 비즈니스 로직으로 분류하는게 맞다고 생각한다. Controller은 url에 따라 행할 행동을 결정하고, 그에 따른 응답을 반환하는 책임이 있다. 변환이라는 책임은 반환이라는 책임과 분리해야 한다는게 나의 의견이다. 따라서 변환의 행위 자체는 service에서 하도록 구현을 했다. 그럼 변환에 대한 api는 어디에 선언해야할까? 보통은 변환의 주체인 객체에서 선언하는 것 같다. 이 방법을 사용하면 외부에서 getter의 사용이 불필요해지기 때문에 좋아보이며, 그 객체가 다른 객체로 변환하는 행동을 그 객체 자신이게 책임을 지게 한다. 하지만, 나는 이거도 결국은 변환에 대한 책임이 분리가 되는게 아닌가 라고 생각해서 Mapper라는 클래스를 생성했고, 해당 도메인에 대해 모든 변환 책임을 모았다. 프로젝트가 거대해지는게 어느 정도인지 감이 안와서 사실 이게 맞나라는 의문심이 들지만, 우선 이에 대해 내가 생각하는 장점을 말하자면 다음과 같다. 첫번째는 서로 다른 엔티티가 합쳐져서 새로운 DTO가 만들어질 때, 어떤 엔티티에 이에 대한 책임을 물게할지가 애매하다. 두번째는 아까 언급했던 것처럼 변환에 대한 책임을 하나로 모을 수 있다. service에 대한 패키지에 Mapper 클래스를 위치시키고 protected 접근제한자로 노출 범위를 제한하면, controller에서의 사용에 대해서도 막을 수 있다.
2. 외부로의 노출에 대한 방어를 마지막 controllder에게 지게 하면 외부로의 노출을 피하기 위해서 controller에 부담이 생긴다. 상황에 따라서 서비스에서 반환되는 값이 엔티티일 수도 있고, 그냥 다른 값일 수도 있다. controller는 로직을 담담하지 않아 엔티티에 관심이 주지 않아도 됐지만, 서비스에서 반환된 값의 변환 필요성을 결정하기 위해 이 값에 노출되면 안되는 정보가 있는지를 일일이 확인해야한다. 이건 유지보수에 좋지 않을 것이라고 판단된다.

이런 이유로 entity 변환은 service에서 담당해야 한다고 생각한다.



## 

---

## 연관관계 우선순위 정렬

##### 상황

-  Store, StoreMenuGroup, StoreMenu, MenuOptionGroup, MenuOption 엔티티가 1:N 관계로 맺어져있는데, storeId로 이를 모두 가져오려고 할 때, 모두 필드로 가지는 priority 순서로 가져와야함.

##### 해결

- `@EntityGraph` 를 이용해서 fetch join을 하는 방법으로 조회를 할 때, priority 순서로 조회되도록 하기 위해서는 엔티티에서 `@Order`을 이용하면 된다.

  ```java
  @Entity
  public class Store {
      @Id
      private Long id;
  
      ...
  
      @OneToMany(mappedBy = "store")
      @OrderBy("priority ASC")
      private List<StoreMenuGroup> menuGroups;
  }
  
  ```

  
